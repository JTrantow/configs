
loadrt [KINS]KINEMATICS
loadrt [EMCMOT]EMCMOT servo_period_nsec=[EMCMOT]SERVO_PERIOD num_joints=[KINS]JOINTS
loadrt hostmot2
loadrt hm2_eth board_ip="10.10.10.10" config=" num_encoders=4 num_stepgens=4" 
setp    hm2_7i92.0.watchdog.timeout_ns 5000000
loadrt pid names=pid.x,pid.y,pid.z,pid.s
loadrt abs names=abs.spindle
loadrt lowpass names=lowpass.spindle
loadrt debounce cfg=1,1,1 
loadrt scale names=scale.spindle
#
# load the user space component for the Automation Direct GS2 VFD's
#
loadusr -Wn spindle-vfd gs2_vfd -r 9600 -p none -s 2 --name spindle-vfd --accel-seconds 5 --decel-seconds 3 --braking-resistor --device /dev/ttyUSB0

addf hm2_7i92.0.read          servo-thread
addf motion-command-handler   servo-thread
addf motion-controller        servo-thread
addf pid.x.do-pid-calcs       servo-thread
addf pid.y.do-pid-calcs       servo-thread
addf pid.z.do-pid-calcs       servo-thread
addf pid.s.do-pid-calcs       servo-thread
addf abs.spindle              servo-thread
addf lowpass.spindle          servo-thread
addf hm2_7i92.0.write         servo-thread
addf debounce.0               servo-thread
addf debounce.1               servo-thread
addf debounce.2               servo-thread

setp hm2_7i92.0.dpll.01.timer-us -50
setp hm2_7i92.0.stepgen.timer-number 1

#*******************
#  AXIS X JOINT 0
#*******************
setp   pid.x.Pgain     [JOINT_0]P
setp   pid.x.Igain     [JOINT_0]I
setp   pid.x.Dgain     [JOINT_0]D
setp   pid.x.bias      [JOINT_0]BIAS
setp   pid.x.FF0       [JOINT_0]FF0
setp   pid.x.FF1       [JOINT_0]FF1
setp   pid.x.FF2       [JOINT_0]FF2
setp   pid.x.deadband  [JOINT_0]DEADBAND
setp   pid.x.maxoutput [JOINT_0]MAX_OUTPUT
setp   pid.x.error-previous-target true
setp   pid.x.maxerror 0.012700

net x-index-enable  <=> pid.x.index-enable
net x-enable        =>  pid.x.enable
net x-pos-cmd       =>  pid.x.command
net x-pos-fb        =>  pid.x.feedback
net x-output        <=  pid.x.output

# Step Gen signals/setup

setp   hm2_7i92.0.stepgen.00.dirsetup        [JOINT_0]DIRSETUP
setp   hm2_7i92.0.stepgen.00.dirhold         [JOINT_0]DIRHOLD
setp   hm2_7i92.0.stepgen.00.steplen         [JOINT_0]STEPLEN
setp   hm2_7i92.0.stepgen.00.stepspace       [JOINT_0]STEPSPACE
setp   hm2_7i92.0.stepgen.00.position-scale  [JOINT_0]STEP_SCALE
setp   hm2_7i92.0.stepgen.00.step_type        0
setp   hm2_7i92.0.stepgen.00.control-type     1
setp   hm2_7i92.0.stepgen.00.maxaccel         [JOINT_0]STEPGEN_MAXACCEL
setp   hm2_7i92.0.stepgen.00.maxvel           [JOINT_0]STEPGEN_MAXVEL

# ---closedloop stepper signals---

net x-pos-cmd    <= joint.0.motor-pos-cmd
net x-output     <= hm2_7i92.0.stepgen.00.velocity-cmd
net x-enable     <= joint.0.amp-enable-out
net x-enable     => hm2_7i92.0.stepgen.00.enable

# ---Encoder feedback signals/setup---

setp    hm2_7i92.0.encoder.00.counter-mode 0
setp    hm2_7i92.0.encoder.00.filter 1
setp    hm2_7i92.0.encoder.00.index-invert 0
setp    hm2_7i92.0.encoder.00.index-mask 0
setp    hm2_7i92.0.encoder.00.index-mask-invert 0
setp    hm2_7i92.0.encoder.00.scale  [JOINT_0]ENCODER_SCALE
net x-index-enable   <= joint.0.index-enable             =>  hm2_7i92.0.encoder.00.index-enable
#
# In open loop,   -pos-fb goes directly from stepgen to joint.
# In closed loop, -pos-fb is provided by the encoder position.
#
#net x-pos-fb     <= hm2_7i92.0.stepgen.00.position-fb =>  joint.0.motor-pos-fb
net x-pos-fb         <=  hm2_7i92.0.encoder.00.position  =>  joint.0.motor-pos-fb

# ---setup home / limit switch signals---
net x-home-sw        <= hm2_7i92.0.gpio.019.in =>  joint.0.home-sw-in joint.0.neg-lim-sw-in

#*******************
#  AXIS Y JOINT 1
#*******************
#
# The first PID compensates for servo thread timestamp dither. 
#
#
# For a closed loop stepper (where the motor is closed by the driver) with 1khz servo loop, use P=1000, FF1=1.0.
#
setp   pid.y.Pgain     [JOINT_1]P
setp   pid.y.Igain     [JOINT_1]I
setp   pid.y.Dgain     [JOINT_1]D
setp   pid.y.bias      [JOINT_1]BIAS
setp   pid.y.FF0       [JOINT_1]FF0
setp   pid.y.FF1       [JOINT_1]FF1
setp   pid.y.FF2       [JOINT_1]FF2
setp   pid.y.deadband  [JOINT_1]DEADBAND
setp   pid.y.maxoutput [JOINT_1]MAX_OUTPUT
setp   pid.y.error-previous-target true
setp   pid.y.maxerror 0.1

net y-pos-cmd       =>  pid.y.command
net y-output        <=  pid.y.output
net y-index-enable  <=> pid.y.index-enable
net y-enable        =>  pid.y.enable
#
# Stepgen setup
#
setp   hm2_7i92.0.stepgen.01.dirsetup        [JOINT_1]DIRSETUP
setp   hm2_7i92.0.stepgen.01.dirhold         [JOINT_1]DIRHOLD
setp   hm2_7i92.0.stepgen.01.steplen         [JOINT_1]STEPLEN
setp   hm2_7i92.0.stepgen.01.stepspace       [JOINT_1]STEPSPACE
setp   hm2_7i92.0.stepgen.01.position-scale  [JOINT_1]STEP_SCALE
setp   hm2_7i92.0.stepgen.01.step_type        0
setp   hm2_7i92.0.stepgen.01.control-type     1
setp   hm2_7i92.0.stepgen.01.maxaccel         [JOINT_1]STEPGEN_MAXACCEL
setp   hm2_7i92.0.stepgen.01.maxvel           [JOINT_1]STEPGEN_MAXVEL

# ---closedloop stepper signals---

net y-output     <= hm2_7i92.0.stepgen.01.velocity-cmd
net y-enable     <= joint.1.amp-enable-out              => hm2_7i92.0.stepgen.01.enable
net y-pos-cmd    <= joint.1.motor-pos-cmd

#
# ---Encoder feedback signals/setup---
#
setp    hm2_7i92.0.encoder.01.counter-mode 0
setp    hm2_7i92.0.encoder.01.filter 1
setp    hm2_7i92.0.encoder.01.index-invert 0
setp    hm2_7i92.0.encoder.01.index-mask 0
setp    hm2_7i92.0.encoder.01.index-mask-invert 0
setp    hm2_7i92.0.encoder.01.scale  [JOINT_1]ENCODER_SCALE

#
#  Seems like motion doesn't like using encoder with HOME_USE_INDEX?
#
#net y-pos-fb        <=  hm2_7i92.0.stepgen.01.position-fb =>  pid.y.feedback 
#net y-encoder-pos   <=  hm2_7i92.0.encoder.01.position    =>  joint.1.motor-pos-fb
net y-encoder-pos   <=  hm2_7i92.0.encoder.01.position    =>  joint.1.motor-pos-fb => pid.y.feedback 

net y-index-enable    <= joint.1.index-enable            =>  hm2_7i92.0.encoder.01.index-enable

# ---setup home / limit switch signals---
net y-home-sw   <= hm2_7i92.0.gpio.021.in    =>  joint.1.home-sw-in joint.1.pos-lim-sw-in

#*******************
#  AXIS Z JOINT 2
#*******************
setp   pid.z.Pgain     [JOINT_2]P
setp   pid.z.Igain     [JOINT_2]I
setp   pid.z.Dgain     [JOINT_2]D
setp   pid.z.bias      [JOINT_2]BIAS
setp   pid.z.FF0       [JOINT_2]FF0
setp   pid.z.FF1       [JOINT_2]FF1
setp   pid.z.FF2       [JOINT_2]FF2
setp   pid.z.deadband  [JOINT_2]DEADBAND
setp   pid.z.maxoutput [JOINT_2]MAX_OUTPUT
setp   pid.z.error-previous-target true
setp   pid.z.maxerror 0.012700

net z-index-enable  <=> pid.z.index-enable
net z-enable        =>  pid.z.enable
net z-pos-cmd       =>  pid.z.command
net z-pos-fb        =>  pid.z.feedback
net z-output        <=  pid.z.output

# Step Gen signals/setup

setp   hm2_7i92.0.stepgen.02.dirsetup        [JOINT_2]DIRSETUP
setp   hm2_7i92.0.stepgen.02.dirhold         [JOINT_2]DIRHOLD
setp   hm2_7i92.0.stepgen.02.steplen         [JOINT_2]STEPLEN
setp   hm2_7i92.0.stepgen.02.stepspace       [JOINT_2]STEPSPACE
setp   hm2_7i92.0.stepgen.02.position-scale  [JOINT_2]STEP_SCALE
setp   hm2_7i92.0.stepgen.02.step_type        0
setp   hm2_7i92.0.stepgen.02.control-type     1
setp   hm2_7i92.0.stepgen.02.maxaccel         [JOINT_2]STEPGEN_MAXACCEL
setp   hm2_7i92.0.stepgen.02.maxvel           [JOINT_2]STEPGEN_MAXVEL

# ---closedloop stepper signals---

net z-pos-cmd    <= joint.2.motor-pos-cmd
net z-output     <= hm2_7i92.0.stepgen.02.velocity-cmd
net z-enable     <= joint.2.amp-enable-out
net z-enable     => hm2_7i92.0.stepgen.02.enable

# ---Encoder feedback signals/setup---

setp    hm2_7i92.0.encoder.02.counter-mode 0
setp    hm2_7i92.0.encoder.02.filter 1
setp    hm2_7i92.0.encoder.02.index-invert 0
setp    hm2_7i92.0.encoder.02.index-mask 0
setp    hm2_7i92.0.encoder.02.index-mask-invert 0
setp    hm2_7i92.0.encoder.02.scale  [JOINT_2]ENCODER_SCALE
net z-index-enable    <= joint.2.index-enable             =>  hm2_7i92.0.encoder.02.index-enable

#
# In open loop,   -pos-fb goes directly from stepgen to joint.
# In closed loop, -pos-fb is provided by the encoder position.
#
net z-pos-fb     <= hm2_7i92.0.stepgen.02.position-fb   => joint.2.motor-pos-fb
#net z-pos-fb          <=  hm2_7i92.0.encoder.02.position  => joint.2.motor-pos-fb

# ---setup home / limit switch signals---
net z-home-sw       <= hm2_7i92.0.gpio.017.in =>  joint.2.home-sw-in joint.2.pos-lim-sw-in

#*******************
#  SPINDLE
#*******************

# --- Spindle Encoder signals/setup---
setp    hm2_7i92.0.encoder.03.counter-mode 0
setp    hm2_7i92.0.encoder.03.filter 1
setp    hm2_7i92.0.encoder.03.index-invert 1
setp    hm2_7i92.0.encoder.03.index-mask 0
setp    hm2_7i92.0.encoder.03.index-mask-invert 0
setp    hm2_7i92.0.encoder.03.scale  -4000

setp   pid.s.Pgain     [SPINDLE_0]P
setp   pid.s.Igain     [SPINDLE_0]I
setp   pid.s.Dgain     [SPINDLE_0]D
setp   pid.s.bias      [SPINDLE_0]BIAS
setp   pid.s.FF0       [SPINDLE_0]FF0
setp   pid.s.FF1       [SPINDLE_0]FF1
setp   pid.s.FF2       [SPINDLE_0]FF2
setp   pid.s.deadband  [SPINDLE_0]DEADBAND
setp   pid.s.maxoutput [SPINDLE_0]MAX_OUTPUT
setp   pid.s.error-previous-target true

# Connect the Mesa encoder signals.
net spindle-revs         <= hm2_7i92.0.encoder.03.position
net spindle-vel-fb-rps   <= hm2_7i92.0.encoder.03.velocity
net spindle-index-enable <= hm2_7i92.0.encoder.03.index-enable 

#
# GS2 VFD 
#
#net gs2-fwd spindle-vfd.spindle-fwd <= spindle.0.forward
#net gs2-run spindle-vfd.spindle-on <= spindle.0.on
#net gs2-at-speed spindle.0.at-speed <= spindle-vfd.at-speed
#net gs2-RPM spindle-vfd.speed-command <= spindle.0.speed-out
#
# Rename gs2- signals to work with configuration tool.
#
net spindle-cw          <= spindle-vfd.spindle-fwd
net spindle-enable      <= spindle-vfd.spindle-on 
net spindle-at-speed    <= spindle-vfd.at-speed
net spindle-vel-cmd-rpm <= spindle-vfd.speed-command

#
# Complete list from documentation for gs2-vfd spindle.
#
#<name>.DC-bus-volts (float, out)from the VFD
#<name>.at-speed (bit, out)when drive is at commanded speed
#<name>.err-reset (bit, in)reset errors sent to VFD
#<name>.firmware-revision (s32, out)from the VFD
#<name>.frequency-command (float, out)from the VFD
#<name>.frequency-out (float, out)from the VFD
#<name>.is-stopped (bit, out)when the VFD reports 0 Hz output
#<name>.load-percentage (float, out)from the VFD
#<name>.motor-RPM (float, out)from the VFD
#<name>.output-current (float, out)from the VFD
#<name>.output-voltage (float, out)from the VFD
#<name>.power-factor (float, out)from the VFD
#<name>.scale-frequency (float, out)from the VFD
#<name>.speed-command (float, in) speed sent to VFD in RPM It is an error to send a speed faster than the Motor Max RPM as set in the VFD
#<name>.spindle-fwd (bit, in) 1 for FWD and 0 for REV sent to VFD
#<name>.spindle-on (bit, in)1 for ON and 0 for OFF sent to VFD, only on when running
#<name>.spindle-rev (bit, in)1 for ON and 0 for OFF, only on when running
#<name>.status-1 (s32, out)Drive Status of the VFD (see the GS2 manual)
#<name>.status-2 (s32, out) Drive Status of the VFD (see the GS2 manual) Note that the value is a sum of all the bits that are on. So a 163 which means the drive is in the run mode is the sum of 3 (run) + 32 (freq set by serial) + 128 (operation set by serial).

#
# Who decided to set up a velocity pid.s for the spindle??? Why?
#
net spindle-index-enable  <=> pid.s.index-enable
net spindle-enable        =>  pid.s.enable
net spindle-vel-cmd-rpm   =>  pid.s.command
net spindle-vel-fb-rpm    =>  pid.s.feedback
net spindle-output        <=  pid.s.output

# ---setup spindle control signals---
#
#<name>.amp-fault-in IN BIT Should be driven TRUE if an external fault is detected with the amplifier for this spindle
#<name>.at-speed IN BIT Motion will pause until this pin is TRUE, under the following conditions: before the first feed move after each spindle start or speed change; before the start of every chain of spindle-synchronized moves; and if in CSS mode, at every rapid->feed transition.
#<name>.brake OUT BIT TRUE when the spindle brake should be applied
#<name>.forward OUT BIT TRUE when the spindle should rotate forward
#<name>.index-enable I/O BIT For correct operation of spindle synchronized moves, this signal must be hooked to the index-enable pin of the spindle encoder.
#<name>.inhibit IN BIT When TRUE, the spindle speed is set and held to 0.
#<name>.is-oriented IN BIT Acknowledge pin for spindle-orient. Completes orient cycle. If spindle-orient was true when spindle-is-oriented was asserted, the spindle-orient pin is cleared and the spindle-locked pin is asserted. Also, the spindle-brake pin is asserted.
#<name>.locked OUT BIT Spindle orient complete pin. Cleared by any of M3,M4,M5.
#<name>.on OUT BIT TRUE when spindle should rotate
#<name>.orient OUT BIT Indicates start of spindle orient cycle. Set by M19. Cleared by any of M3,M4,M5. If spindle-orient-fault is not zero during spindle-orient true, the M19 command fails with an error message.
#<name>.orient-angle OUT FLOAT Desired spindle orientation for M19. Value of the M19 R word parameter plus the value of the [RS274NGC]ORIENT_OFFSET ini parameter.
#<name>.orient-fault IN S32 Fault code input for orient cycle. Any value other than zero will cause the orient cycle to abort.
#<name>.orient-mode OUT BIT Desired spindle rotation mode. Reflects M19 P parameter word.
#<name>.reverse OUT BIT TRUE when the spindle should rotate backward
#<name>.revs IN FLOAT For correct operation of spindle synchronized moves, this signal must be hooked to the position pin of the spindle encoder.
#<name>.speed-cmd-rps FLOAT OUT Commanded spindle speed in units of revolutions per second
#<name>.speed-in IN FLOAT Actual spindle speed feedback in revolutions per second; used for G96 (constant surface speed) and G95 (feed per revolution) modes.
#<name>.speed-out OUT FLOAT Desired spindle speed in rotations per minute
#<name>.speed-out-abs OUT FLOAT Desired spindle speed in rotations per minute, always positive regardless of spindle direction.
#<name>.speed-out-rps OUT FLOAT Desired spindle speed in rotations per second
#<name>.speed-out-rps-abs OUT FLOAT Desired spindle speed in rotations per second, always positive regardless of spindle direction.

net spindle-vel-cmd-rps        <=  spindle.0.speed-out-rps
net spindle-vel-cmd-rps-abs    <=  spindle.0.speed-out-rps-abs
net spindle-vel-cmd-rpm        <=  spindle.0.speed-out
net spindle-vel-cmd-rpm-abs    <=  spindle.0.speed-out-abs

net spindle-enable             <=  spindle.0.on
net spindle-cw                 <=  spindle.0.forward
net spindle-ccw                <=  spindle.0.reverse
net spindle-brake              <=  spindle.0.brake
net spindle-revs               =>  spindle.0.revs
net spindle-at-speed           =>  spindle.0.at-speed
net spindle-vel-fb-rps         =>  spindle.0.speed-in
net spindle-index-enable      <=>  spindle.0.index-enable

# ---Setup spindle at speed signals---

#sets spindle-at-speed true


#******************************
# connect miscellaneous signals
#******************************

#  ---HALUI signals---

net axis-select-x  halui.axis.x.select
net jog-x-pos      halui.axis.x.plus
net jog-x-neg      halui.axis.x.minus
net jog-x-analog   halui.axis.x.analog
net x-is-homed     halui.joint.0.is-homed
net axis-select-y  halui.axis.y.select
net jog-y-pos      halui.axis.y.plus
net jog-y-neg      halui.axis.y.minus
net jog-y-analog   halui.axis.y.analog
net y-is-homed     halui.joint.1.is-homed
net axis-select-z  halui.axis.z.select
net jog-z-pos      halui.axis.z.plus
net jog-z-neg      halui.axis.z.minus
net jog-z-analog   halui.axis.z.analog
net z-is-homed     halui.joint.2.is-homed
net jog-selected-pos      halui.axis.selected.plus
net jog-selected-neg      halui.axis.selected.minus
net spindle-manual-cw     halui.spindle.0.forward
net spindle-manual-ccw    halui.spindle.0.reverse
net spindle-manual-stop   halui.spindle.0.stop
net machine-is-on         halui.machine.is-on
net jog-speed             halui.axis.jog-speed
net MDI-mode              halui.mode.is-mdi

#  ---coolant signals---

net coolant-mist      <=  iocontrol.0.coolant-mist
net coolant-flood     <=  iocontrol.0.coolant-flood

#
#  ---probe signal---
# Using a tool set input pin OR a probe pin to drive motion.probe-input.
#
loadrt or2 names=or2_probe 
addf or2_probe servo-thread

setp debounce.2.delay 20  # 20 * servo-thread period (1000us) = 20ms

net length-in-raw   <= hm2_7i92.0.gpio.027.in  => debounce.2.0.in
net length-in       <= debounce.2.0.out       => or2_probe.in0
net probe-in        <= hm2_7i92.0.gpio.033.in => or2_probe.in1
net probe-or-length <= or2_probe.out          => motion.probe-input

#  ---motion control signals---

net in-position               <=  motion.in-position
net machine-is-enabled        <=  motion.motion-enabled

#  ---digital in / out signals---


#  ---manual tool change signals---
loadusr -W hal_manualtoolchange
#net tool-change-request     iocontrol.0.tool-change       =>  hal_manualtoolchange.change
#net tool-change-confirmed   iocontrol.0.tool-changed      <=  hal_manualtoolchange.changed
#net tool-number             iocontrol.0.tool-prep-number  =>  hal_manualtoolchange.number
#net tool-prepare-loopback   iocontrol.0.tool-prepare      =>  iocontrol.0.tool-prepared

